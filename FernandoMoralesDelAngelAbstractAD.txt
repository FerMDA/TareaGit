Principios SOLID
Un diseño orientado a objetos está pensado para un software al que se le pueda dar mantenimiento y en un futuro extender las funcionalidades que ofrece, para ello se emplean 5 principios de diseño que se resumen con el acrónimo en inglés SOLID.
El principio de responsabilidad única establece que una clase solo debe de tener un trabajo, si una clase tienen múltiples funcionalidades y se requiere alguna modificación de una función se podría afectar a toda la clase.
El principio abierto-cerrado establece que los objetos o entidades deben de estar abiertos para extensión pero cerrados para modificación, es decir, se debe de tener la facilidad de agregar nuevas funcionalidades o características del programa sin modificar las clases ya existentes.
El principio de sustitución de Liskov dice que cada subclase o clase derivada debe ser sustituible por su clase base o padre, para que esto sea posible no deben de haber restricciones adicionales en las subclases.
El principio de segregación de interfaz dice que nunca se debe obligar a un cliente a implementar una interfaz que no usa, o no se debe obligar a los clientes a depender de métodos que no usan.
El principio de inversión de dependencia establece que las entidades deben depender de abstracciones, no de concreciones, el módulo de alto nivel no debe depender del módulo de bajo nivel, sino que debe depender de abstracciones.


Otros principios en programación orientada a objetos.
El principio DRY nos dice que no debemos de repetir código, en lugar de eso podemos usar abstracciones, no debemos de abusar de este principio, por eso es importante recordar que la duplicación no es por código sino por funcionalidad.
Encapsular el código que se espera o sospecha que tendrá cambios en un futuro para que de esta manera sea más fácil probarlo y darle mantenimiento.
Favorecer la composición sobre la herencia, ambas tienen ventajas y desventajas pero se debe de favorecer a la composición, la composición permite cambiar el comportamiento de una clase en tiempo de ejecución, además de que al iniciar el desarrollo es más lento y complejo, pero después ofrece ventajas para el mantenimiento, cambios, testing y añadirle nuevas funcionalidades.
Programación para la interfaz no implementación, un programador siempre debe programar para la interfaz y no para la implementación, esto conducirá a un código flexible que puede funcionar con cualquier nueva implementación de la interfaz, se debe usar el tipo de interfaz en las variables, los tipos de retorno de un método o el tipo de argumento de los métodos en Java, como usar el tipo SuperClass para almacenar objetos en lugar de usar SubClass.
Principio de delegación, no debemos de hacer todas las cosas por nuestra cuenta, se debe delegar a la clase respectiva, es decir, tenemos la opción de utilizar clases que ya están predefinidas en el lenguaje.
Patrón de diseño MVC
El patrón de diseño MVC especifica que una aplicación consta de un modelo de datos, información de presentación e información de control, este patrón requiere que cada uno de estos se separe en diferentes objetos.
El modelo contiene solo los datos puros de la aplicación, no contiene ninguna lógica que describa cómo presentar los datos a un usuario.
La Vista presenta los datos del modelo al usuario. La vista sabe cómo acceder a los datos del modelo, pero no sabe qué significan estos datos o qué puede hacer el usuario para manipularlos.
El controlador existe entre la vista y el modelo. Escucha los eventos desencadenados por la vista (u otra fuente externa) y ejecuta la reacción adecuada a estos eventos. En la mayoría de los casos, la reacción es llamar a un método en el modelo. Dado que la vista y el modelo están conectados a través de un mecanismo de notificación, el resultado de esta acción se refleja automáticamente en la vista.
Las ventajas del patrón MVC son que varios desarrolladores pueden trabajar simultáneamente en el proyecto, permite la agrupación lógica de acciones relacionadas en un controlador. Las vistas de un modelo específico también se agrupan y los modelos pueden tener varias vistas.
Las desventajas del patrón MVC son que la navegación del marco puede ser compleja porque introduce nuevas capas de abstracción y requiere que los usuarios se adapten a los criterios de descomposición de MVC, además el conocimiento de múltiples tecnologías se convierte en la norma. Los desarrolladores que utilizan MVC deben ser expertos en múltiples tecnologías.
El objetivo de este patrón es tener nuestro código ordenado y separado, porque es incorrecto que para modificar alguna funcionalidad tengamos que ir a una vista, y al tener nuestro código separado y ser independiente se puede modificar sin afectar la funcionalidad de otro grupo.

Arquitectura en capas
El patrón de arquitectura en capas también conocido  como patrón de arquitectura de N niveles es el estándar de facto para la mayoría de las aplicaciones Java EE, el patrón de arquitectura en capas no especifica el número y los tipos de capas que deben existir en el patrón, la mayoría de las arquitecturas en capas constan de cuatro capas estándar: presentación, negocio, persistencia y base de datos. En algunos casos, la capa de negocio y la capa de persistencia se combinan en una sola capa de negocio, particularmente cuando la lógica de persistencia (por ejemplo, SQL o HSQL) está incrustada dentro de los componentes de la capa de negocio. Por lo tanto, las aplicaciones más pequeñas pueden tener solo tres capas, mientras que las aplicaciones comerciales más grandes y complejas pueden contener cinco o más capas.
Cada capa del patrón de arquitectura en capas tiene un rol y una responsabilidad específicos dentro de la aplicación. Por ejemplo, una capa de presentación sería responsable de manejar toda la interfaz de usuario y la lógica de comunicación del navegador, mientras que una capa comercial sería responsable de ejecutar reglas comerciales específicas asociadas con la solicitud. Cada capa de la arquitectura forma una abstracción en torno al trabajo que debe realizarse para satisfacer una solicitud comercial en particular. Por ejemplo, la capa de presentación no necesita saber ni preocuparse por cómo obtener datos del cliente; solo necesita mostrar esa información en una pantalla en un formato particular.
Una capa cerrada significa que a medida que una solicitud se mueve de una capa a otra, debe atravesar la capa que está justo debajo para llegar a la siguiente capa debajo de esa.
El concepto de capas de aislamiento significa que los cambios realizados en una capa de la arquitectura generalmente no afectan ni afectan a los componentes de otras capas: el cambio se aísla a los componentes dentro de esa capa y posiblemente a otra capa asociada (como una capa de persistencia que contenga SQL).
Aprovechar el concepto de capas abiertas y cerradas ayuda a definir la relación entre las capas de la arquitectura y los flujos de solicitudes y también proporciona a los diseñadores y desarrolladores la información necesaria para comprender las diversas restricciones de acceso a las capas dentro de la arquitectura. No documentar o comunicar correctamente qué capas de la arquitectura están abiertas y cerradas (y por qué) generalmente da como resultado arquitecturas frágiles y estrechamente acopladas que son muy difíciles de probar, mantener e implementar.
El patrón de arquitectura en capas tiene una agilidad general baja, es decir, no responde rápidamente a un entorno en constante cambio, la implementación se vuelve difícil cuando se le quieren agregar cambios, tiene un puntaje de testeo alto, el rendimiento es bajo porque se tienen que pasar por múltiples para cumplir una solicitud, su escalabilidad es baja pero es fácil  implementar al ser un patrón de diseño muy conocido.

Principios KISS YAGNI y DRY
Suele ocurrir que caemos que caemos en la trampa de diseñar un proyecto de una forma más compleja de lo necesario, que incluso es difícil de comprender por el propio programador, por ello es necesario tener en cuenta unos principios básicos muy poderosos que harán las cosas más fáciles.
La programación de KISS, en particular, es muy importante. Trate de tener esto en mente en sus esfuerzos. Cuanto más simple sea su código, más sencillo será mantenerlo en el futuro. Esto será muy apreciado por cualquier otra persona que necesite examinar su código en el futuro.
